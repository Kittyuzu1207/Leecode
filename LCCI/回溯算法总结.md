# 回溯算法总结
## 典型例题：0407M括号 0407M幂集  
回溯的意义：但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择  
核心思想：找到停止条件，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径  

## 解决步骤：  
1. 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解  
2. 确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。  
3. 以深度优先的方式DFS搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索【比如重复的解】

## 典例：八皇后问题
在8X8格的国际象棋上摆放八个皇后（棋子），使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。  
Step1 将八皇后问题转化为四皇后问题，并用回溯法来找到它的解  
![Image text](https://github.com/Kittyuzu1207/Leecode/blob/master/img/皇后1.png)
Step2 第二行的皇后只能放在第三格或第四格，比方我们放第三格，则： 
![Image text](https://github.com/Kittyuzu1207/Leecode/blob/master/img/皇后2.png)
Step3 可以看到再难以放下第三个皇后，此时我们就要用到回溯算法了。我们把第二个皇后更改位置，此时我们能放下第三枚皇后了。  
![Image text](https://github.com/Kittyuzu1207/Leecode/blob/master/img/皇后3.png)

实现八皇后问题  
第一步 我们要判断每次输入的皇后是否在同一行同一列，或者同一斜线上。  
```python
def is_ok(row):            
    j=0  
    while j<row:  
        if (queen[row]==queen[j] or row-queen[row]==j-queen[j] or row+queen[row]==j+queen[j])  
            return False  
        j+=1  
    return True  
```
第二步 实现核心算法  
```python
def back_tracking(row=0):    #从第0行开始遍历
    if (row==n):
        t +=1               #判断若遍历完成，就进行计数     
        for col in range(n):    #遍历棋盘每一列
            queen[row] = col         #将皇后的位置记录在数组
            if (is_ok(row))             #判断皇后的位置是否有冲突
                back_tracking(row+1)   #递归，计算下一个皇后的位置
```        
