#给定一个放有字符和数字的数组，找到最长的子数组，且包含的字符和数字的个数相同。
#返回该子数组，若存在多个最长子数组，返回左端点最小的。若不存在这样的数组，返回一个空数组。

#example
#输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]
#输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]


#差值字典
#使用一个字典, 数字与字符数目的差值diff作为key, value是前i个数的差值为key的起始下标
#只需要存1个下标, 遇到新的下标的时候直接判断是否要更新s和e即可


#注意需要额外处理diff=0的情况
#注意结果是[s+1:e]
#注意输入存在多位数字的情况..

class Solution:
    def findLongestSubarray(self, array: List[str]) -> List[str]:
        diffToStartIndex={}
        diff=0
        s,e=0,-1
        for i,c in enumerate(array):
            if '0'<=c[0]<='9':
                diff+=1
            else:
                diff-=1
            if diff==0 and i>e-s:
                s,e=-1,i
            if diff not in diffToStartIndex:
                diffToStartIndex[diff]=i
            elif i - diffToStartIndex[diff] > e - s:
                s, e = diffToStartIndex[diff], i
        return array[s + 1:e + 1]


'''
数字看成-1，字母看成1，再计算前缀和。
前缀和 相同则计算下标的差值。

技巧：使用int[]数组memo存储 该前缀和 第1次出现时 的下标。
为何是第1次出现时的下标？
因为要求最长子数组。

比如：
["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]

转化为[1, -1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1]

再转为前缀和形式[1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 1, 0, 1, 2, 3, 4, 5, 6]。

前缀和相同是什么意思呢？

比如看加粗的2个1：[1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 1, 0, 1, 2, 3, 4, 5, 6]

说明这2个1的下标所构成的区间内的数字和为0，而数字和为0说明有相同个数的1和-1，即相同个数的字母和数字。

具体来说：第1个加粗的1下标为0，第2个加粗的1下标为2，构成区间(0, 2](注意：是半开半闭)，
区间(0, 2]内元素的和即下标为1和下标为2的元素之和，[1, -1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1]
很明显-1 + 1 = 0

理解了这一点，剩余的工作就是找前缀和相同，且相隔最远的2个元素。

什么才是相隔最远？

[1, 0, 1, 2, 3, 2, 1, 0, 1, 0, 1, 2, 1, 0, 1, 2, 3, 4, 5, 6]

单只看前缀和为1的情况，毫无疑问，前缀和为1时，相隔最远的肯定是最左边的1和最右边的1.

因此我们只需要记录前缀和为1第一次出现时的下标即可(也就是记录了最左边的1的位置)，以后再遇到前缀和为1时，只需要将其下标 - 所记录的最左边的1的位置 即可。

至于memo数组大小为何初始化为(len << 1) + 1，考虑最极端的情况，要么全为-1，要么全为1，对应前缀和为-array.length和array.length。

特别注意:
当前缀和为0时，假设其下标为n，则说明区间[0, n]内所有元素的和为0，区间长度为n + 1。
因此将memo[0 + array.length]的值设为-1，因为n - (-1) = n + 1。

同时由于数组下标不能为负数，因此需要映射处理:
假设数组有2个元素，边界值为-2和2，即[-2, -1, 0, 1, 2]。
将[-2, -1, 0, 1, 2] 集体右移nums.length个单位，映射为[0, 1, 2, 3, 4]。
'''
